# U-Boot boot script for YIOS developer image
# fdtargs args patching based on: https://github.com/Opentrons/buildroot/blob/opentrons-develop/board/opentrons/ot2/boot.scr
# Sets the correct root partition in the boot arguments inside the flattened device tree.

# Create the required env vars for boot count & limit support.
# Note: bootcount and bootlimit are already defined in U-Boot.
# - rootfspart holds the currently active root partition to boot
if test -z "${rootfspart}"
then
    echo "No saved rootfspart, defaulting to 2"
    setenv rootfspart "2"
    saveenv
fi

# - altbootcmd to execute when boot limit is reached
if test -z "${altbootcmd}"
then
    echo "No saved altbootcmd, creating it"
    setenv altbootcmd "
oldrootfspart='\${rootfspart}';
if test \"'\${rootfspart}'\" = \"2\";
then
    setenv rootfspart 3;
else
    setenv rootfspart 2;
fi;
setenv bootcount 0;
saveenv;
echo Rollback from rootfs '\${oldrootfspart}' to old rootfs '\${rootfspart}';
boot"
    saveenv
fi

# Parse and replace the boot arguments in the flattened device tree.
# This allows us to keep the RPi cmdline.txt without hardcoded bootargs.
# The raspi second stage bootloader (start.elf) puts the boot args in the
# flattened device tree. The boot args contain the partition the kernel
# will boot off of, so we have to pull the boot args, parse them, and then
# (later) edit them and resave them
fdt addr $fdt_addr
fdt get value fdtargs /chosen bootargs
# Iterate through bootargs and save everything but the boot partition
newargs=""
for arg in $fdtargs; do
    if test "root=/dev/mmcblk0p2" = $arg
    then
        bootpart=$arg
    else
        newargs="$newargs $arg"
    fi
done

if test "$upgrade_available" = "1"
then
    echo "Try booting system upgrade from partition ${rootfspart}. Boot count: $bootcount. Limit for rollback: $bootlimit"
else
    echo "Booting from active partition ${rootfspart}"
fi

# Note: setting an invalid root param will hang the boot process due to required `rootwait` argument, which waits indefinitely!
#       A hackish workaround for a kernel panic to trigger a reboot would be using rootdelay=xx instead, but that delays the boot for xx seconds.
#       However: since we are loading the kernel from the same partition, the script will fail before booting the kernel. So it should be safe to use.
to_boot="$newargs root=/dev/mmcblk0p${rootfspart}"
fdt set /chosen bootargs "$to_boot"
if ext4load mmc 0:${rootfspart} $kernel_addr_r /zImage; then
    bootz $kernel_addr_r - $fdt_addr
fi

echo "Boot failed!"
# Reset loop might not be the best choice, but there's not much we can do here.
# Better solution would require to initialize the display in U-Boot and display an error screen. That's another project...
reset